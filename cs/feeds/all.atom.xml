<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jan Buchar</title><link href="https://bucharjan.cz/cs/" rel="alternate"></link><link href="https://bucharjan.cz/feeds/all.atom.xml" rel="self"></link><id>https://bucharjan.cz/cs/</id><updated>2017-07-31T14:45:00+02:00</updated><entry><title>Using Cython to protect a Python codebase</title><link href="https://bucharjan.cz/cs/blog/using-cython-to-protect-a-python-codebase-en.html" rel="alternate"></link><published>2017-07-31T14:45:00+02:00</published><updated>2017-07-31T14:45:00+02:00</updated><author><name>Jan Buchar</name></author><id>tag:bucharjan.cz,2017-07-31:/cs/blog/using-cython-to-protect-a-python-codebase-en.html</id><summary type="html">&lt;p&gt;Recently, I worked on a Python project that required the whole codebase to be 
protected using Cython. Although protecting Python sources from reverse 
engineering seems like a futile task at first, cythonizing all the code leads to 
a reasonable amount of security (the binary is very difficult to disassemble, 
but …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Recently, I worked on a Python project that required the whole codebase to be 
protected using Cython. Although protecting Python sources from reverse 
engineering seems like a futile task at first, cythonizing all the code leads to 
a reasonable amount of security (the binary is very difficult to disassemble, 
but it's still possible to e.g. monkey patch parts of the program). &lt;/p&gt;
&lt;p&gt;This security comes with a price though - the primary use case for Cython is
writing compiled extensions that can easily interface with Python code.
Therefore, the support for non-trivial module/package structures is rather
limited and we have to do some extra work to achieve the desired results.&lt;/p&gt;
&lt;p&gt;The first obstacle we had to overcome was that it's difficult to compile a whole
Python package (as in "directory containing an &lt;code&gt;__init__.py&lt;/code&gt; file") with Cython. 
Imagine the following structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;src
├── mypkg
│   ├── bar.py
│   ├── foo.py
│   └── __init__.py
├── mypkg2
│   ├── bar.py
│   ├── foo.py
│   └── __init__.py
└── setup.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The recommended way of cythonizing this would be using a &lt;code&gt;setup.py&lt;/code&gt; file such as 
this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;setuptools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;setuptools.extension&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Extension&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Cython.Build&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cythonize&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Cython.Distutils&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;build_ext&lt;/span&gt;

&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;ext_modules&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cythonize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;
           &lt;span class="n"&gt;Extension&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg.*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg/*.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
           &lt;span class="n"&gt;Extension&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg2.*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg2/*.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="n"&gt;build_dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;build&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;compiler_directives&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;always_allow_keywords&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="p"&gt;)),&lt;/span&gt;
    &lt;span class="n"&gt;cmdclass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;build_ext&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;build_ext&lt;/span&gt;
    &lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;packages&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mypkg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;mypkg2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;setup.py&lt;/code&gt; is more or less what you would expect from a project that uses 
Cython. There are two things to be noted though. First, the 
&lt;code&gt;always_allow_keywords&lt;/code&gt; directive makes it possible for Flask view functions to 
work correctly by disabling an optimization that only allows keyword arguments 
for functions with a lot of parameters. Second, we do not use the &lt;code&gt;ext_package&lt;/code&gt; 
parameter suggested by some guides, which would put the cythonized code into 
another package. By omitting it, the compiled code is kept in the same place.&lt;/p&gt;
&lt;p&gt;However, after we build our project with &lt;code&gt;python setup.py build_ext&lt;/code&gt;, we notice 
that the resulting package cannot be imported - it is missing an &lt;code&gt;__init__.py&lt;/code&gt; 
file. There is &lt;code&gt;__init__.so&lt;/code&gt; that can be imported from Python, but that isn't 
enough to make a directory a package in Python's eyes. Not being able to import 
the package is not the only problem - code inside it cannot perform 
package-relative imports (e.g. &lt;code&gt;from .foo import foo&lt;/code&gt;) either, which breaks its 
functionality.&lt;/p&gt;
&lt;p&gt;To remedy this problem, we can copy the &lt;code&gt;__init__.py&lt;/code&gt; file from our source tree 
after the rest of the project is built. A good way to do so is overriding the 
&lt;code&gt;build_ext&lt;/code&gt; class in &lt;code&gt;setup.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ...&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pathlib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;shutil&lt;/span&gt;

&lt;span class="c1"&gt;# ...&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyBuildExt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;build_ext&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;build_ext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;build_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build_lib&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;root_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__file__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;

        &lt;span class="n"&gt;target_dir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;build_dir&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inplace&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;root_dir&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mypkg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__init__.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target_dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mypkg2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__init__.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target_dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mypkg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target_dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;mypkg2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;__main__.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target_dir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;copy_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;source_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;destination_dir&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_dir&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;

        &lt;span class="n"&gt;shutil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copyfile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_dir&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;destination_dir&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="c1"&gt;# ...&lt;/span&gt;
    &lt;span class="n"&gt;cmdclass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;build_ext&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;MyBuildExt&lt;/span&gt;
    &lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="c1"&gt;# ...&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;We have successfully created Python packages that can be imported from. They 
reside under &lt;code&gt;build/lib.linux-x86_64-3.6&lt;/code&gt; or something similar. Sadly, this is 
not enough for the distribution of our package. Ideally, we'd like to have an 
installable package that only contains compiled code. The current standard for 
Python archives is the wheel format (.whl), which aims to replace the .egg 
format. So, let's try to create a wheel with &lt;code&gt;python setup.py bdist_wheel&lt;/code&gt;! 
After the command finishes, there should be a &lt;code&gt;dist&lt;/code&gt; folder that contains a 
wheel file. Unpacking it yields something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── mypkg
│   ├── bar.cpython-36m-x86_64-linux-gnu.so
│   ├── bar.py
│   ├── foo.cpython-36m-x86_64-linux-gnu.so
│   ├── foo.py
│   ├── __init__.cpython-36m-x86_64-linux-gnu.so
│   └── __init__.py
├── mypkg-0.0.0.dist-info
│   ├── DESCRIPTION.rst
│   ├── METADATA
│   ├── metadata.json
│   ├── RECORD
│   ├── top_level.txt
│   └── WHEEL
└── mypkg2
    ├── bar.cpython-36m-x86_64-linux-gnu.so
    ├── bar.py
    ├── foo.cpython-36m-x86_64-linux-gnu.so
    ├── foo.py
    ├── __init__.cpython-36m-x86_64-linux-gnu.so
    └── __init__.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Apparently, the archive contains not only compiled code, but also the sources. 
There is a way to fix this, however counter-intuitive it might seem. We need to 
remove our packages from the &lt;code&gt;packages&lt;/code&gt; argument of the &lt;code&gt;setup&lt;/code&gt; call. This way, 
the extensions will still be built and included in the wheel, but the source 
code will not.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="c1"&gt;# ...&lt;/span&gt;
    &lt;span class="n"&gt;packages&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The content of the built wheel should then look like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dist/
├── mypkg
│   ├── bar.cpython-36m-x86_64-linux-gnu.so
│   ├── foo.cpython-36m-x86_64-linux-gnu.so
│   ├── __init__.cpython-36m-x86_64-linux-gnu.so
│   └── __init__.py
├── mypkg-0.0.0.dist-info
│   ├── DESCRIPTION.rst
│   ├── METADATA
│   ├── metadata.json
│   ├── RECORD
│   ├── top_level.txt
│   └── WHEEL
└── mypkg2
    ├── bar.cpython-36m-x86_64-linux-gnu.so
    ├── foo.cpython-36m-x86_64-linux-gnu.so
    ├── __init__.cpython-36m-x86_64-linux-gnu.so
    └── __init__.py
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The wheel can be installed with &lt;code&gt;pip install dist/*.whl&lt;/code&gt;. If we do not need to 
inspect the wheel or distribute it manually, we can just run &lt;code&gt;pip install .&lt;/code&gt; in 
the project directory, which builds the wheel and installs it for us.&lt;/p&gt;
&lt;p&gt;It is also possible to strip Python source code from .egg archives, but it 
involves overriding the &lt;code&gt;bdist_egg&lt;/code&gt; command from &lt;code&gt;setuptools&lt;/code&gt;. I won't cover 
that here, but if you're interested, check out the &lt;code&gt;--exclude-source-files&lt;/code&gt; 
option and the &lt;code&gt;zap_pyfiles&lt;/code&gt; method of aforementioned command class.&lt;/p&gt;
&lt;p&gt;By following this guide, you should be able to cythonize a Python codebase with 
non-trivial package/module structure, thus making it difficult for evil hackers 
to reverse engineer it and steal your programming know-how.&lt;/p&gt;</content><category term="Python"></category><category term="Cython"></category></entry><entry><title>Custom modifier-only shortcuts in Plasma 5.8</title><link href="https://bucharjan.cz/cs/blog/plasma-custom-modifier-only-shortcuts-en.html" rel="alternate"></link><published>2016-10-07T15:00:00+02:00</published><updated>2016-10-07T15:00:00+02:00</updated><author><name>Jan Buchar</name></author><id>tag:bucharjan.cz,2016-10-07:/cs/blog/plasma-custom-modifier-only-shortcuts-en.html</id><summary type="html">&lt;p&gt;The latest release of KDE Plasma (5.8) brought a new feature - it can open the 
desktop menu when the meta (super, Windows...) key is pressed. Like in Windows 
XP, remember? Alas, it's not yet possible to configure this to do something more 
useful in the GUI, however weird this …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The latest release of KDE Plasma (5.8) brought a new feature - it can open the 
desktop menu when the meta (super, Windows...) key is pressed. Like in Windows 
XP, remember? Alas, it's not yet possible to configure this to do something more 
useful in the GUI, however weird this seems in a LTS release. After digging in 
KWin's source code for a while, I found a way to set custom shortcuts in the 
config files.&lt;/p&gt;
&lt;p&gt;First, make sure KWin isn't running. I recommend opening a terminal and running 
&lt;code&gt;killall kwin_x11&lt;/code&gt;. Now let's say we'd like to open krunner when Meta is pressed 
and the desktop menu should be opened with Shift. Edit &lt;code&gt;~/.config/kwinrc&lt;/code&gt; and 
add the following lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[ModifierOnlyShortuts]&lt;/span&gt;
&lt;span class="na"&gt;Meta&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;org.kde.krunner,/App,,display&lt;/span&gt;
&lt;span class="na"&gt;Shift&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;org.kde.plasmashell,/PlasmaShell,org.kde.PlasmaShell,activateLauncherMenu&lt;/span&gt;
&lt;span class="na"&gt;Alt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="na"&gt;Control&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The double comma in the &lt;code&gt;Meta&lt;/code&gt; value is not a typo. It means something like that 
the called function is not in a namespace, in contrast to the function in the 
&lt;code&gt;Shift&lt;/code&gt; value. An empty value means no action will be bound to the modifier.&lt;/p&gt;
&lt;p&gt;Now, you just need to run KWin again with &lt;code&gt;kwin_x11 --replace&lt;/code&gt; and everything 
should work. Note that it should be possible to bind any qdbus call to a 
modifier key like this. Try using &lt;code&gt;qdbusviewer&lt;/code&gt; to explore the possibilites!&lt;/p&gt;</content><category term="KDE"></category><category term="Plasma"></category><category term="KWin"></category><category term="Linux"></category></entry><entry><title>My web development setup with uWSGI</title><link href="https://bucharjan.cz/cs/blog/web-development-setup-with-uwsgi-en.html" rel="alternate"></link><published>2016-09-05T21:05:00+02:00</published><updated>2016-09-05T21:05:00+02:00</updated><author><name>Jan Buchar</name></author><id>tag:bucharjan.cz,2016-09-05:/cs/blog/web-development-setup-with-uwsgi-en.html</id><summary type="html">&lt;p&gt;Until recently, I've used pretty much the same LAMP environment I installed when 
I started with GNU/Linux. It had many drawbacks, the most important being 
cryptic configuration (hello, mod_rewrite) and the need to edit files as root 
when adding new applications using VirtualHosts. Also, running Python 
applications is quite …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Until recently, I've used pretty much the same LAMP environment I installed when 
I started with GNU/Linux. It had many drawbacks, the most important being 
cryptic configuration (hello, mod_rewrite) and the need to edit files as root 
when adding new applications using VirtualHosts. Also, running Python 
applications is quite a pain with Apache and mod_wsgi - most of the time, I just 
went with whatever development server my framework offered.&lt;/p&gt;
&lt;p&gt;Then I stumbled upon uWSGI. I was blown away with how versatile this web 
application server is - it supports a plethora of programming languages, has a 
powerful routing system and loads of other features. I experimented with it for 
some time and this is the result - a flexible web development environment using 
uWSGI and Nginx.&lt;/p&gt;
&lt;h2&gt;Pluggable applications with uWSGI&lt;/h2&gt;
&lt;p&gt;First, we'll start uWSGI in Emperor mode. It will monitor a path and make sure 
that all uWSGI configuration files found there are running. It also reloads the 
applications when their configuration changes. We'll be putting our applications 
in &lt;code&gt;~/WWW&lt;/code&gt;, with the following structure:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;~/WWW
├── app1
│   ├── app1.ini
│   ├── file1
│   └── file2
└── app2
    ├── app2.ini
    ├── file1
    └── file2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;As we see, there is a folder for each application that contains its sources and 
also a uWSGI configuration file. The name of this file is used as the vassal 
name by the Emperor. We'll start the Emperor now:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;uwsgi --emperor &lt;span class="s2"&gt;&amp;quot;~/WWW/*/*.ini&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
      --emperor-on-demand-directory /tmp/uwsgi/ &lt;span class="se"&gt;\&lt;/span&gt;
      --logto %h/WWW/uwsgi.log &lt;span class="se"&gt;\&lt;/span&gt;
      --vassals-set socket-chmod&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;666&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
      --vassals-set &lt;span class="nv"&gt;idle&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;900&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
      --vassals-set die-on-idle&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;--emperor-on-demand-directory&lt;/code&gt; flag tells the Emperor to make a UNIX domain 
socket for each application (named &lt;code&gt;&amp;lt;vassal_name&amp;gt;.socket&lt;/code&gt;) in given directory 
and activate the application when someone connects to that socket. When we 
combine this with &lt;code&gt;--idle&lt;/code&gt; and &lt;code&gt;--die-on-idle&lt;/code&gt; on the vassals, we get a 
webserver that automatically stops unused applications and their daemons. &lt;/p&gt;
&lt;p&gt;We also need nginx to have read and write access to the sockets - that's why we 
set their permissions to 666. If we wanted to be a bit more strict, we could 
make a group for our user and nginx and &lt;code&gt;chown&lt;/code&gt; the sockets to this group.&lt;/p&gt;
&lt;p&gt;Now, let's add an application! This one will be in PHP, but use whatever you 
feel like. First, the "application" itself:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;# ~/WWW/testapp/index.php&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;?php&lt;/span&gt;
&lt;span class="k"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Hello from uWSGI&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, we'll write the configuration file that tells uWSGI how to run it. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ~/WWW/testapp/testapp.ini&lt;/span&gt;
&lt;span class="k"&gt;[uwsgi]&lt;/span&gt;
&lt;span class="na"&gt;chdir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%d&lt;/span&gt;

&lt;span class="c1"&gt;# PHP settings&lt;/span&gt;
&lt;span class="na"&gt;plugin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;0:php&lt;/span&gt;
&lt;span class="na"&gt;php-docroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%d&lt;/span&gt;
&lt;span class="na"&gt;check-static&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%d&lt;/span&gt;
&lt;span class="na"&gt;php-app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;%d/index.php&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Noticed the &lt;code&gt;0:&lt;/code&gt; in the &lt;code&gt;plugin&lt;/code&gt; option? This little detail is actually really 
important - it tells uWSGI to route HTTP requests to the PHP plugin. For more 
details, see the documentation for &lt;code&gt;modifier1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Emperor should now notice the configuration file and run our application. 
It is however bound to a UNIX domain socket - to access it, we need a 
webserver to forward actual HTTP requests to it.&lt;/p&gt;
&lt;h2&gt;Nginx - the fixed part&lt;/h2&gt;
&lt;p&gt;Nginx will serve as a gateway to our applications. It should pass requests to 
subdomains on localhost to corresponding UNIX domain sockets that belong to the 
uWSGI vassals - requests on &lt;code&gt;myapp.localhost&lt;/code&gt; will be passed to 
&lt;code&gt;/tmp/uwsgi/myapp.socket&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# nginx.conf&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt;&lt;span class="sr"&gt;^(?&amp;lt;app&amp;gt;[^.]+)\.localhost;&lt;/span&gt;

                &lt;span class="s"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;uwsgi_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="kn"&gt;uwsgi_pass&lt;/span&gt; &lt;span class="s"&gt;unix:/tmp/uwsgi/&lt;/span&gt;&lt;span class="nv"&gt;$app.socket&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This is not a complete configuration file - I only included the relevant parts. 
That being said, you should now be able to open &lt;code&gt;testapp.localhost&lt;/code&gt; in a web 
browser and see the output!&lt;/p&gt;
&lt;h2&gt;Bonus - running uWSGI with systemd&lt;/h2&gt;
&lt;p&gt;If you're running a recent GNU/Linux distribution, it's likely that you use 
systemd. One of its better features is that it lets users run their own services 
without any special privileges. We'll use that to make sure our uWSGI Emperor is 
always running. First, we create a systemd unit file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ~/.config/systemd/user/uwsgi-emperor.service&lt;/span&gt;
&lt;span class="k"&gt;[Unit]&lt;/span&gt;
&lt;span class="na"&gt;Description&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;uWSGI Emperor&lt;/span&gt;

&lt;span class="k"&gt;[Service]&lt;/span&gt;
&lt;span class="na"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/mkdir -p /tmp/uwsgi/&lt;/span&gt;
&lt;span class="na"&gt;ExecStartPre&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/chmod 777 /tmp/uwsgi/&lt;/span&gt;
&lt;span class="na"&gt;ExecStart&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;/usr/bin/uwsgi \&lt;/span&gt;
&lt;span class="s"&gt;          --emperor &amp;quot;%h/WWW/*/*.ini&amp;quot; \&lt;/span&gt;
&lt;span class="s"&gt;          --emperor-on-demand-directory /tmp/uwsgi/ \&lt;/span&gt;
&lt;span class="s"&gt;          --logto %h/WWW/uwsgi.log \&lt;/span&gt;
&lt;span class="s"&gt;          --vassals-set socket-chmod=666 \&lt;/span&gt;
&lt;span class="s"&gt;          --vassals-set idle=900 \&lt;/span&gt;
&lt;span class="s"&gt;          --vassals-set die-on-idle=1&lt;/span&gt;

&lt;span class="k"&gt;[Install]&lt;/span&gt;
&lt;span class="na"&gt;WantedBy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;default.target&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now we'll make sure that the uWSGI Emperor starts when we log in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ systemctl --user daemon-reload
$ systemctl --user &lt;span class="nb"&gt;enable&lt;/span&gt; uwsgi-emperor
$ systemctl --user start uwsgi-emperor
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have set up a development environment where we can program in Python, Ruby, 
PHP and tons of other languages (I also used it to run Pelican when I wrote this 
post). All our code runs under a regular user (if that wasn't enough, uWSGI can 
sandbox it using lxc). The applications are accessible with pretty URLs on the 
standard HTTP port, which makes it easy to test them on various devices.&lt;/p&gt;</content><category term="uwsgi"></category><category term="nginx"></category><category term="linux"></category><category term="web"></category><category term="python"></category><category term="php"></category></entry></feed>